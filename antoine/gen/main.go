package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

type antoineData struct {
	Name    string  `json:"name"`
	Formula string  `json:"formula"`
	A       float64 `json:"a"`
	B       float64 `json:"b"`
	C       float64 `json:"c"`
	TMin    float64 `json:"t_min"`
	TMax    float64 `json:"t_max"`
	H       float64 `json:"h"`
	Tn      float64 `json:"tn"`
}

func main() {
	input := filepath.Join("../data", "b2_antoine.json")
	out := "table.go"

	b, err := os.ReadFile(input)
	if err != nil {
		log.Fatal(err)
	}

	var data []antoineData
	if err := json.Unmarshal(b, &data); err != nil {
		log.Fatal(err)
	}

	f, err := os.Create(out)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	fmt.Fprintln(f, "// Code generated by go generate; DO NOT EDIT.")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "package antoine")
	fmt.Fprintln(f)

	var count int

	fmt.Println("#------------------------------------------------------#")

	// Emit variables
	for _, s := range data {
		id := goIdent(s.Name)

		fmt.Fprintf(f, "var %s = Antoine{\n", id)
		fmt.Printf("Processing %s\n", id)
		fmt.Fprintf(f, "\tName: %q,\n", s.Name)
		fmt.Fprintf(f, "\tFormula: %q,\n", s.Formula)
		fmt.Fprintf(f, "\tA: %.5f,\n", s.A)
		fmt.Fprintf(f, "\tB: %.5f,\n", s.B)
		fmt.Fprintf(f, "\tC: %.5f,\n", s.C)
		fmt.Fprintf(f, "\tH: %.5f,\n", s.H)
		fmt.Fprintf(f, "\tRange: TempRange{\n")
		fmt.Fprintf(f, "\t\tLow: %.5f,\n", s.TMin)
		fmt.Fprintf(f, "\t\tHigh: %.5f,\n", s.TMax)
		fmt.Fprintf(f, "\t},\n")
		fmt.Fprintf(f, "\tTn: %.5f,\n", s.Tn)
		fmt.Fprintf(f, "}\n\n")

		count++
	}
	fmt.Printf("Processed %d substances(Antoine)\n", count)
}

func goIdent(name string) string {
	// Remove content in parentheses (and everything after, to handle unclosed parens)
	re := regexp.MustCompile(`\s*\(.*`)
	name = re.ReplaceAllString(name, "")

	// Handle leading digits
	if len(name) > 0 && name[0] >= '0' && name[0] <= '9' {
		digitMap := map[byte]string{
			'0': "Zero", '1': "One", '2': "Two", '3': "Three", '4': "Four",
			'5': "Five", '6': "Six", '7': "Seven", '8': "Eight", '9': "Nine",
		}
		if val, ok := digitMap[name[0]]; ok {
			name = val + name[1:]
		}
	}

	name = strings.ReplaceAll(name, "-", " ")
	name = strings.ReplaceAll(name, ",", "")
	name = strings.ReplaceAll(name, "(", "")
	name = strings.ReplaceAll(name, ")", "")
	parts := strings.Fields(name)

	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
		}
	}

	return strings.Join(parts, "")
}
