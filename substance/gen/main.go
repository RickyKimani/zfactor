package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

type criticalProps struct {
	Tc float64 `json:"tc"`
	Pc float64 `json:"pc"`
	Vc float64 `json:"vc"`
	Zc float64 `json:"zc"`
}

type substance struct {
	Name     string        `json:"name"`
	MW       float64       `json:"mw"`
	Acentric float64       `json:"acentric"`
	Tn       float64       `json:"tn"`
	Critical criticalProps `json:"critical"`
}

func main() {
	input := filepath.Join("../data", "b1_char_prop.json")
	out := "table.go"

	b, err := os.ReadFile(input)
	if err != nil {
		log.Fatal(err)
	}

	var subs []substance
	if err := json.Unmarshal(b, &subs); err != nil {
		log.Fatal(err)
	}

	f, err := os.Create(out)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	fmt.Fprintln(f, "// Code generated by go generate; DO NOT EDIT.")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "package substance")
	fmt.Fprintln(f)

	var count int
	fmt.Println("#------------------------------------------------------#")

	// Emit variables
	for _, s := range subs {
		id := goIdent(s.Name)

		fmt.Printf("Processing substance %s\n", id)

		fmt.Fprintf(f, "var %s = Substance{\n", id)
		fmt.Fprintf(f, "\tName: %q,\n", s.Name)
		fmt.Fprintf(f, "\tMW: %.5f,\n", s.MW)
		fmt.Fprintf(f, "\tAcentric: %.5f,\n", s.Acentric)
		fmt.Fprintf(f, "\tTn: %.5f,\n", s.Tn)
		fmt.Fprintf(f, "\tCritical: CriticalProps{\n")
		fmt.Fprintf(f, "\t\tTc: %.5f,\n", s.Critical.Tc)
		fmt.Fprintf(f, "\t\tPc: %.5f,\n", s.Critical.Pc)
		fmt.Fprintf(f, "\t\tVc: %.5f,\n", s.Critical.Vc)
		fmt.Fprintf(f, "\t\tZc: %.5f,\n", s.Critical.Zc)
		fmt.Fprintf(f, "\t},\n")
		fmt.Fprintf(f, "}\n\n")

		count++
	}

	fmt.Printf("Processed %d substances\n", count)
	fmt.Println("#------------------------------------------------------#")
}

func goIdent(name string) string {
	// Remove content in parentheses (and everything after, to handle unclosed parens)
	re := regexp.MustCompile(`\s*\(.*`)
	name = re.ReplaceAllString(name, "")

	// Handle leading digits
	if len(name) > 0 && name[0] >= '0' && name[0] <= '9' {
		digitMap := map[byte]string{
			'0': "Zero", '1': "One", '2': "Two", '3': "Three", '4': "Four",
			'5': "Five", '6': "Six", '7': "Seven", '8': "Eight", '9': "Nine",
		}
		if val, ok := digitMap[name[0]]; ok {
			name = val + name[1:]
		}
	}

	name = strings.ReplaceAll(name, "-", " ")
	name = strings.ReplaceAll(name, ",", "")
	parts := strings.Fields(name)

	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
		}
	}

	return strings.Join(parts, "")
}
